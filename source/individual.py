""""
Class that represents the entire entity of mujoco. Because the mujoco env is generated by one xml file,
the individual class contains and the mujoco environment and the neural network of the entity.
"""

# Standard Library Imports
import os
import uuid
import math
from pathlib import Path

# Third-Party Library Imports
import gymnasium as gym
from PIL import Image
import torch
from torch import Tensor
from scipy.spatial.transform import Rotation
from gymnasium.wrappers import RecordVideo
from gymnasium.envs.mujoco.ant_v4 import AntEnv

# Local Application/Library Imports
from source.neural_network import NeuralNetwork
from source.mj_env import MJEnv, Morphology


class Individual:
    """Individual containing the Mujoco env and the neural network"""

    def __init__(
        self,
        device: str,
        morph_params_bounds_enc: tuple[float, float],
        penalty_growth_rate: float,
        penalty_scale_factor: int,
        penalty_scale_factor_err: int,
        dis_morph_evo: bool = False
    ):
        self.dis_morph_evo = dis_morph_evo
        self.uid: uuid.UUID = uuid.uuid4()
        self.device = device
        self.mj_env = MJEnv(self.uid, morph_params_bounds_enc, dis_morph_evo)
        self.controller = NeuralNetwork(self.uid).to(self.device)
        self.params_size = self.mj_env.morphology.total_params + self.controller.total_weigths
        self.generation: int = 0

        self.train_ant_xml_folder: str = "train_ant_xml"
        os.makedirs(self.train_ant_xml_folder, exist_ok=True)
        os.makedirs("train_terrain_noise", exist_ok=True)

        self.penalty_growth_rate: float = penalty_growth_rate
        self.penalty_scale_factor: int = penalty_scale_factor
        self.penalty_scale_factor_err: int = penalty_scale_factor_err

    def set_generation(self, generation: int):
        """
        Method that sets the current generation of this individual. 
        This must be kept up to date after every generation/episode.
        """
        self.generation = generation

    def setup_ant_hills(self, params: Tensor, floor_height: float, scale: int):
        """Method to initialize the individual in the hills terrain environment."""
        nn_params, morph_params = torch.split(
            params, (self.controller.total_weigths, self.mj_env.morphology.total_params)
        )
        self.controller.set_nn_params(nn_params)
        self.mj_env.setup_ant_hills(floor_height, scale, morph_params)

    def setup_ant_rough(self, params: Tensor, floor_height: float, block_size: int):
        """Method to initialize the individual in the rough terrain environment."""
        nn_params, morph_params = torch.split(
            params, (self.controller.total_weigths, self.mj_env.morphology.total_params)
        )
        self.controller.set_nn_params(nn_params)
        self.mj_env.setup_ant_rough(floor_height, block_size, morph_params)

    def setup_ant_default(self, params: Tensor):
        """Method to initialize the individual in the default terrain environment."""
        nn_params, morph_params = torch.split(
            params, (self.controller.total_weigths, self.mj_env.morphology.total_params)
        )
        self.controller.set_nn_params(nn_params)
        self.mj_env.setup_ant_default(morph_params=morph_params)

    def evaluate_fitness(self, render_mode: str = None, video_save_path: str = None) -> float:
        """Method to run the simulation in the mujoco environment that was initialized and evaluate the fitness score."""
        if self.mj_env.has_invalid_parameters():
            return -self._penalty_function(self.penalty_scale_factor_err)

        generated_ant_xml: str = f"./{self.train_ant_xml_folder}/generated_ant_xml_{self.uid}.xml"
        with open(generated_ant_xml, "w") as file:
            file.write(self.mj_env.xml_str)

        env: AntEnv = gym.make(
            "Ant-v4", xml_file=generated_ant_xml, healthy_z_range=(-1, 7.5), render_mode=render_mode, camera_name="track"
        )
        if render_mode == "rgb_array":
            assert (
                video_save_path is not None
            ), "Specify video_save_path if render_mode is set to 'rgb_array'"
            env = RecordVideo(
                env,
                video_folder=video_save_path,
                name_prefix="eval",
                episode_trigger=lambda x: True,
            )
        total_reward: float = 0
        episodes: int = 1
        for _ in range(episodes):
            obs, _ = env.reset()
            prev_distance_from_origin: int = 0
            distance_counter: int = 0
            done: bool = False
            while not done:
                obs_tensor: Tensor = torch.from_numpy(obs).to(self.device)
                action = self.controller(obs_tensor)
                obs, reward, terminated, truncated, info = env.step(action)
                total_reward += reward
                if render_mode == "human":
                    env.render()

                if math.isclose(
                    info["distance_from_origin"], prev_distance_from_origin, abs_tol=1e-2
                ):
                    distance_counter += 1
                else:
                    distance_counter = 0
                prev_distance_from_origin = info["distance_from_origin"]
                done = (
                    terminated or truncated or distance_counter > 300 or self._is_upside_down(env)
                )
            env.close()

        # if os.path.exists(generated_ant_xml):
        #     os.remove(generated_ant_xml)
        return (total_reward / episodes) - self._penalty_function(self.penalty_scale_factor)

    def make_screenshot_ant(self, path: str):
        """
        Method that creates a photo of the ant and saves it in a specific path. 
        The file name itself must also be passed with the path.
        """
        if self.mj_env.has_invalid_parameters():
            return

        generated_ant_xml: str = f"./{self.train_ant_xml_folder}/generated_ant_xml_{self.uid}.xml"
        with open(generated_ant_xml, "w") as file:
            file.write(self.mj_env.xml_str)

        env: AntEnv = gym.make(
            "Ant-v4",
            render_mode="rgb_array",
            xml_file=generated_ant_xml,
            healthy_z_range=(-1, 7.5),
            camera_name="topdown",
        )

        env.reset()
        frame = env.render()
        image = Image.fromarray(frame)
        image.save(f"{path}")

        env.close()
        if os.path.exists(generated_ant_xml):
            os.remove(generated_ant_xml)

    def make_screenshot_env(self, path: str):
        """Method that creates a photo of the environment and saves it in a specific path. The file name itself must also be passed with the path."""
        if self.mj_env.has_invalid_parameters():
            return

        generated_ant_xml: str = f"./{self.train_ant_xml_folder}/generated_ant_xml_{self.uid}.xml"
        with open(generated_ant_xml, "w") as file:
            file.write(self.mj_env.xml_str)

        env: AntEnv = gym.make(
            "Ant-v4",
            render_mode="rgb_array",
            xml_file=generated_ant_xml,
            healthy_z_range=(0.26, 4),
            camera_name="env",
        )

        env.reset()
        frame = env.render()
        image = Image.fromarray(frame)
        image.save(f"{path}")

        env.close()
        if os.path.exists(generated_ant_xml):
            os.remove(generated_ant_xml)

    def print_controller_info(self):
        """Method that prints certain information to the console."""
        print("Controller Parameters:")
        print(
            f"{self.controller.input_size} Inp (+1 bias) -> {self.controller.hidden_size} Hid (+1 bias) -> {self.controller.output_size} Out"
        )
        print(f"Total Weights: {self.controller.total_weigths}")

    def _print_env_info(self, env: AntEnv):
        print(f"Action Space:\n{env.action_space}\n")
        print(f"Observation Space:\n{env.observation_space}\n")

    def _is_upside_down(self, env: AntEnv):
        q = env.get_wrapper_attr("data").body("torso").xquat
        q = [q[1], q[2], q[3], q[0]]  # convert quaternion from wxyz to xyzw
        q = Rotation.from_quat(q)

        rotation_matrix = q.as_matrix()
        up_vector = rotation_matrix[2]  # z-vector

        return up_vector[2] < -0.75

    def _penalty_function(self, scalar: int) -> float:
        morph_params: Tensor = self.mj_env.morphology.morph_params_tensor
        length_params, width_params = torch.split(
            morph_params, (Morphology.total_leg_length_params, Morphology.total_leg_width_params)
        )

        sum_leg_length_diff = self._get_total_difference(length_params, Morphology.leg_length_range)
        sum_leg_width_diff = self._get_total_difference(width_params, Morphology.leg_width_range)

        penalty = (
            scalar
            * (sum_leg_length_diff + sum_leg_width_diff)
            * (self.penalty_growth_rate**self.generation)
        )
        return penalty

    def _get_total_difference(self, params: Tensor, morph_range: tuple[float, float]) -> float:
        leg_length_lower_diff: Tensor = morph_range[0] - params[params < morph_range[0]]
        leg_length_upper_diff: Tensor = params[params > morph_range[1]] - morph_range[1]
        sum_leg_length_diff: float = (
            leg_length_lower_diff.sum().item() + leg_length_upper_diff.sum().item()
        )

        return sum_leg_length_diff
